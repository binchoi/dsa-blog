<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Week 4 [1-7 Nov 2021] &mdash; AlgoVenture 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Week 5 [8-14 Nov 2021]" href="week5.html" />
    <link rel="prev" title="Week 3 [25-31 Oct 2021]" href="week3.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> AlgoVenture
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Daily Algo Exercise</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="week1.html">Week 1 [13-17 Oct 2021]</a><ul>
<li class="toctree-l2"><a class="reference internal" href="week1.html#day-1-13-oct">Day 1 [13 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-1-two-sum">Question 1: Two Sum</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-2-valid-parentheses">Question 2: Valid Parentheses</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-3-search-insert-position">Question 3: Search Insert Position</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week1.html#day-2-14-oct">Day 2 [14 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-4-pow-x-n">Question 4: Pow(x,n)</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-5-maximum-subarray">Question 5: Maximum Subarray</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-6-is-subsequence">Question 6: Is Subsequence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week1.html#day-3-15-oct">Day 3 [15 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-7-path-sum">Question 7: Path Sum</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-8-best-time-to-buy-and-sell-stock">Question 8: Best Time to Buy and Sell Stock</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-9-reverse-linked-list">Question 9: Reverse Linked List</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week1.html#day-4-16-oct">Day 4 [16 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-10-unique-paths">Question 10: Unique Paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-11-move-zeroes">Question 11: Move Zeroes</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-12-unique-email-addresses">Question 12: Unique Email Addresses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week1.html#day-5-17-oct">Day 5 [17 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-13-generate-parentheses">Question 13: Generate Parentheses</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-14-zigzag-conversion">Question 14: ZigZag Conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="week1.html#question-15-palindrome-number">Question 15: Palindrome Number</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="week2.html">Week 2 [17-24 Oct 2021]</a><ul>
<li class="toctree-l2"><a class="reference internal" href="week2.html#day-6-18-oct">Day 6 [18 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-16-group-anagrams">Question 16: Group Anagrams</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-17-longest-substring-without-repeating-characters">Question 17: Longest Substring Without Repeating Characters</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-18-remove-element">Question 18: Remove Element</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week2.html#day-7-19-oct">Day 7 [19 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-19-combination-sum">Question 19: Combination Sum</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-20-next-greater-element-i">Question 20: Next Greater Element I</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-21-length-of-last-word">Question 21: Length of Last Word</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week2.html#day-8-20-oct">Day 8 [20 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-22-add-two-numbers">Question 22: Add Two Numbers</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-23-intersection-of-two-arrays">Question 23: Intersection of Two Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-24-longest-common-prefix">Question 24: Longest Common Prefix</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week2.html#day-9-21-oct">Day 9 [21 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-25-subsets">Question 25: Subsets</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week2.html#day-10-22-oct">Day 10 [22 Oct]</a></li>
<li class="toctree-l2"><a class="reference internal" href="week2.html#day-11-23-oct">Day 11 [23 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-26-implement-strstr">Question 26: Implement strStr()</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-27-sqrt-x">Question 27: Sqrt(x)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week2.html#day-12-24-oct">Day 12 [24 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-28-permutations">Question 28: Permutations</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-29-plus-one">Question 29: Plus One</a></li>
<li class="toctree-l3"><a class="reference internal" href="week2.html#question-30-plus-one">Question 30: Plus One</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="week3.html">Week 3 [25-31 Oct 2021]</a><ul>
<li class="toctree-l2"><a class="reference internal" href="week3.html#day-13-25-oct">Day 13 [25 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week3.html#question-31-word-break">Question 31: Word Break</a></li>
<li class="toctree-l3"><a class="reference internal" href="week3.html#question-32-same-tree">Question 32: Same Tree</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week3.html#day-14-26-oct">Day 14 [26 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week3.html#question-33-k-th-symbol-in-grammar">Question 33: K-th Symbol in Grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week3.html#day-15-27-oct">Day 15 [27 Oct]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week3.html#question-34-remove-duplicates-from-sorted-list">Question 34: Remove Duplicates from Sorted List</a></li>
<li class="toctree-l3"><a class="reference internal" href="week3.html#question-35-pascal-s-triangle">Question 35: Pascal’s Triangle</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week3.html#day-28-oct">Day ___ [28 Oct]</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Week 4 [1-7 Nov 2021]</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#day-16-1-nov">Day 16 [1 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#question-31-merge-two-sorted-lists">Question 31: Merge Two Sorted Lists</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#day-17-2-nov">Day 17 [2 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#question-32-merge-sorted-array">Question 32: Merge Sorted Array</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#day-18-3-nov">Day 18 [3 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#question-33-valid-palindrome">Question 33: Valid Palindrome</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#day-19-4-nov">Day 19 [4 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#question-34-top-k-frequent-elements">Question 34: Top K Frequent Elements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#day-20-5-nov">Day 20 [5 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#question-35-remove-duplicates-from-sorted-list-ii">Question 35: Remove Duplicates from Sorted List II</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#day-21-6-nov">Day 21 [6 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#question-36-excel-sheet-column-title">Question 36: Excel Sheet Column Title</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#day-22-7-nov">Day 22 [7 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#question-37-isomorphic-strings">Question 37: Isomorphic Strings</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="week5.html">Week 5 [8-14 Nov 2021]</a><ul>
<li class="toctree-l2"><a class="reference internal" href="week5.html#day-23-8-nov">Day 23 [8 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week5.html#question-38-excel-sheet-column-number">Question 38: Excel Sheet Column Number</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week5.html#day-24-9-nov">Day 24 [9 Nov]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="week5.html#question-39-xxxx">Question 39: XXXX</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="toolbox.html">Python Toolkit</a><ul>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#general-purpose-built-in-containers">General Purpose Built-in Containers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="toolbox.html#dictionary">Dictionary</a></li>
<li class="toctree-l3"><a class="reference internal" href="toolbox.html#list">List</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#specialized-built-in-containers">Specialized Built-in Containers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="toolbox.html#collections">Collections</a></li>
<li class="toctree-l3"><a class="reference internal" href="toolbox.html#counter">Counter</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="algosummary.html">Useful Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="algosummary.html#backtracking">Backtracking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="algosummary.html#useful-reference-backtracking">Useful Reference (Backtracking)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="algosummary.html#tree-traversal-algorithms">Tree Traversal Algorithms</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">AlgoVenture</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Week 4 [1-7 Nov 2021]</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="week-4-1-7-nov-2021">
<h1>Week 4 [1-7 Nov 2021]<a class="headerlink" href="#week-4-1-7-nov-2021" title="Permalink to this headline"></a></h1>
<section id="day-16-1-nov">
<h2>Day 16 [1 Nov]<a class="headerlink" href="#day-16-1-nov" title="Permalink to this headline"></a></h2>
<section id="question-31-merge-two-sorted-lists">
<h3>Question 31: Merge Two Sorted Lists<a class="headerlink" href="#question-31-merge-two-sorted-lists" title="Permalink to this headline"></a></h3>
<p><em>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing
together the nodes of the first two lists.</em></p>
<p>My iterative solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
<span class="linenos"> 2</span>    <span class="c1"># list: no node =&gt; None</span>
<span class="linenos"> 3</span>    <span class="c1"># save head of the merged list to return</span>
<span class="linenos"> 4</span>    <span class="n">resHead</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos"> 5</span>    <span class="n">currNodeOne</span> <span class="o">=</span> <span class="n">l1</span>
<span class="linenos"> 6</span>    <span class="n">currNodeTwo</span> <span class="o">=</span> <span class="n">l2</span>
<span class="linenos"> 7</span>    <span class="n">prevNodeRes</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos"> 8</span>    <span class="k">if</span> <span class="n">l1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">l2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 9</span>        <span class="k">return</span> <span class="n">resHead</span>
<span class="linenos">10</span>    <span class="k">elif</span> <span class="n">l1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">11</span>        <span class="k">return</span> <span class="n">l2</span>
<span class="linenos">12</span>    <span class="k">elif</span> <span class="n">l2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">13</span>        <span class="k">return</span> <span class="n">l1</span>
<span class="linenos">14</span>    <span class="k">else</span><span class="p">:</span>
<span class="linenos">15</span>        <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
<span class="linenos">16</span>            <span class="n">resHead</span> <span class="o">=</span> <span class="n">l2</span>
<span class="linenos">17</span>            <span class="n">currNodeTwo</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span>
<span class="linenos">18</span>            <span class="n">prevNodeRes</span> <span class="o">=</span> <span class="n">l2</span>
<span class="linenos">19</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">20</span>            <span class="n">resHead</span> <span class="o">=</span> <span class="n">l1</span>
<span class="linenos">21</span>            <span class="n">currNodeOne</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">next</span>
<span class="linenos">22</span>            <span class="n">prevNodeRes</span> <span class="o">=</span> <span class="n">l1</span>
<span class="linenos">23</span>
<span class="linenos">24</span>    <span class="k">while</span> <span class="n">currNodeOne</span> <span class="ow">and</span> <span class="n">currNodeTwo</span><span class="p">:</span>
<span class="linenos">25</span>        <span class="k">if</span> <span class="n">currNodeOne</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">currNodeTwo</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
<span class="linenos">26</span>            <span class="n">prevNodeRes</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">currNodeTwo</span>
<span class="linenos">27</span>            <span class="n">prevNodeRes</span> <span class="o">=</span> <span class="n">currNodeTwo</span>
<span class="linenos">28</span>            <span class="n">currNodeTwo</span> <span class="o">=</span> <span class="n">currNodeTwo</span><span class="o">.</span><span class="n">next</span>
<span class="linenos">29</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">30</span>            <span class="n">prevNodeRes</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">currNodeOne</span>
<span class="linenos">31</span>            <span class="n">prevNodeRes</span> <span class="o">=</span> <span class="n">currNodeOne</span>
<span class="linenos">32</span>            <span class="n">currNodeOne</span> <span class="o">=</span> <span class="n">currNodeOne</span><span class="o">.</span><span class="n">next</span>
<span class="linenos">33</span>
<span class="linenos">34</span>    <span class="k">if</span> <span class="n">currNodeOne</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">35</span>        <span class="n">prevNodeRes</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">currNodeTwo</span>
<span class="linenos">36</span>    <span class="k">else</span><span class="p">:</span>
<span class="linenos">37</span>        <span class="n">prevNodeRes</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">currNodeOne</span>
<span class="linenos">38</span>
<span class="linenos">39</span>    <span class="k">return</span> <span class="n">resHead</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>The code is quite long. I do think that there is a clear, readable structure to it but I am wondering if there would have been a way
to simplify the code.</p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> - where <code class="docutils literal notranslate"><span class="pre">n=len(l1)+len(l2)</span></code> as all nodes of both lists must be traversed in the worst-case scenario.</p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(1)</span></code> - we need to store <code class="docutils literal notranslate"><span class="pre">resHead</span></code> and <code class="docutils literal notranslate"><span class="pre">prevNodeRes</span></code>.</p></li>
</ul>
</dd>
</dl>
<p>Neat recursive solution (cred: <a class="reference external" href="https://leetcode.com/problems/merge-two-sorted-lists/discuss/9715/Java-1-ms-4-lines-codes-using-recursion">yang</a>):</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">ListNode</span> <span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span> <span class="n">l2</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l1</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">l2</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l2</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">l1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l1</span><span class="p">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">.</span><span class="na">val</span><span class="p">){</span>
        <span class="n">l1</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">l1</span><span class="p">.</span><span class="na">next</span><span class="p">,</span> <span class="n">l2</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">l1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
        <span class="n">l2</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">.</span><span class="na">next</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">l2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>My adaptation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">l1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">l2</span>
    <span class="k">elif</span> <span class="n">l2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">l1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">l1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">l1</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">l1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">l2</span>
</pre></div>
</div>
<p>Iterative (in-place) solution (inspired by: <a class="reference external" href="https://leetcode.com/problems/merge-two-sorted-lists/discuss/9735/Python-solutions-(iteratively-recursively-iteratively-in-place).">OldCodingFarmer</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">l1</span> <span class="ow">and</span> <span class="n">l2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">curr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>
    <span class="n">curr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span>
    <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks:</dt><dd><ul class="simple">
<li><p>Although the actual runtime does not differ too significantly, I noticed interesting tools for implementation in the OldCodingFarmer’s solution that I had
to give it a try myself:</p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sentinel</span> <span class="pre">=</span> <span class="pre">curr</span> <span class="pre">=</span> <span class="pre">ListNode(0)</span></code> is a clever way to initialize both the <code class="docutils literal notranslate"><span class="pre">curr</span></code> traversing pointer-node and the <code class="docutils literal notranslate"><span class="pre">sentinel</span></code> node. I feel like I don’t use
sentinel nodes as often as I should because it clearly simplifies the implementation of certain algorithms.</p></li>
<li><p>Using the given parameters <code class="docutils literal notranslate"><span class="pre">l1</span></code> and <code class="docutils literal notranslate"><span class="pre">l2</span></code> instead of creating new variables would help with memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">curr.next</span> <span class="pre">=</span> <span class="pre">l1</span> <span class="pre">or</span> <span class="pre">l2</span></code> is a concise way of assigning the next node as the node that is not None (of the two)</p></li>
</ol>
</section>
</section>
<section id="day-17-2-nov">
<h2>Day 17 [2 Nov]<a class="headerlink" href="#day-17-2-nov" title="Permalink to this headline"></a></h2>
<section id="question-32-merge-sorted-array">
<h3>Question 32: Merge Sorted Array<a class="headerlink" href="#question-32-merge-sorted-array" title="Permalink to this headline"></a></h3>
<p><em>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements
denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</em></p>
<p>My solution (inspired by <a class="reference external" href="https://leetcode.com/problems/merge-sorted-array/discuss/29522/This-is-my-AC-code-may-help-you">chun</a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 2</span>    <span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 3</span><span class="sd">    Do not return anything, modify nums1 in-place instead.</span>
<span class="linenos"> 4</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 5</span>    <span class="n">pOne</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span>
<span class="linenos"> 6</span>    <span class="n">pTwo</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
<span class="linenos"> 7</span>    <span class="n">pRes</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span>    <span class="k">while</span> <span class="n">pTwo</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
<span class="linenos">10</span>        <span class="k">if</span> <span class="n">pOne</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="linenos">11</span>            <span class="n">nums1</span><span class="p">[</span><span class="n">pRes</span><span class="p">]</span> <span class="o">=</span>  <span class="n">nums2</span><span class="p">[</span><span class="n">pTwo</span><span class="p">]</span>
<span class="linenos">12</span>            <span class="n">pRes</span> <span class="o">-=</span><span class="mi">1</span>
<span class="linenos">13</span>            <span class="n">pTwo</span> <span class="o">-=</span><span class="mi">1</span>
<span class="linenos">14</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">15</span>            <span class="k">if</span> <span class="n">nums2</span><span class="p">[</span><span class="n">pTwo</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">pOne</span><span class="p">]:</span>
<span class="linenos">16</span>                <span class="n">nums1</span><span class="p">[</span><span class="n">pRes</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">pOne</span><span class="p">]</span>
<span class="linenos">17</span>                <span class="n">pRes</span> <span class="o">-=</span><span class="mi">1</span>
<span class="linenos">18</span>                <span class="n">pOne</span> <span class="o">-=</span><span class="mi">1</span>
<span class="linenos">19</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">20</span>                <span class="n">nums1</span><span class="p">[</span><span class="n">pRes</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">pTwo</span><span class="p">]</span>
<span class="linenos">21</span>                <span class="n">pRes</span> <span class="o">-=</span><span class="mi">1</span>
<span class="linenos">22</span>                <span class="n">pTwo</span> <span class="o">-=</span><span class="mi">1</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>I am confident that this is the most time-efficient algorithm. The implementation can definitely be cleaned up more though!</p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n+m)</span></code> - the <code class="docutils literal notranslate"><span class="pre">nums1</span></code> is traversed only once from back to front</p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(1)</span></code> - in-place modifications (still uncertain about space complexity)</p></li>
</ul>
</dd>
</dl>
<p>Elegant Java solution (cred: <a class="reference external" href="https://leetcode.com/problems/merge-sorted-array/discuss/29522/This-is-my-AC-code-may-help-you">chun</a>):</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="o">[]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">B</span><span class="o">[]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span>
                            <span class="n">A</span><span class="o">[</span><span class="n">k</span><span class="o">--]</span> <span class="o">=</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">--]</span><span class="p">;</span>
                    <span class="k">else</span>
                            <span class="n">A</span><span class="o">[</span><span class="n">k</span><span class="o">--]</span> <span class="o">=</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">--]</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">A</span><span class="o">[</span><span class="n">k</span><span class="o">--]</span> <span class="o">=</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">--]</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Elegant Python Solution (cred: <a class="reference external" href="https://leetcode.com/problems/merge-sorted-array/discuss/29503/Beautiful-Python-Solution">cffls</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>                      <span class="c1"># modify given param/variables</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nums1</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>           <span class="c1"># modify in bulk!</span>
</pre></div>
</div>
</section>
</section>
<section id="day-18-3-nov">
<h2>Day 18 [3 Nov]<a class="headerlink" href="#day-18-3-nov" title="Permalink to this headline"></a></h2>
<section id="question-33-valid-palindrome">
<h3>Question 33: Valid Palindrome<a class="headerlink" href="#question-33-valid-palindrome" title="Permalink to this headline"></a></h3>
<p><em>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters,
it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.</em></p>
<p>My solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">def</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos">2</span>    <span class="n">strippedStr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()])</span>
<span class="linenos">3</span>    <span class="k">return</span> <span class="p">(</span><span class="n">strippedStr</span> <span class="o">==</span> <span class="n">strippedStr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>Pretty simple question - learned about <code class="docutils literal notranslate"><span class="pre">.isalnum()</span></code></p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">len(s)</span></code> each character is traversed at least once.</p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">len(s)</span></code> - worst-case: the size of <code class="docutils literal notranslate"><span class="pre">strippedStr</span></code> is equal to that of <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ul>
</dd>
</dl>
</section>
</section>
<section id="day-19-4-nov">
<h2>Day 19 [4 Nov]<a class="headerlink" href="#day-19-4-nov" title="Permalink to this headline"></a></h2>
<section id="question-34-top-k-frequent-elements">
<h3>Question 34: Top K Frequent Elements<a class="headerlink" href="#question-34-top-k-frequent-elements" title="Permalink to this headline"></a></h3>
<p><em>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</em></p>
<p>My solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="linenos">2</span>    <span class="n">myDict</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="n">nums</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">nums</span><span class="p">)}</span>
<span class="linenos">3</span>    <span class="k">return</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">myDict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[:</span><span class="n">k</span><span class="p">]]</span>
</pre></div>
</div>
<dl>
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>Surprisingly slow performance (as compiled in leetcode server). Perhaps due to the sorting?</p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(nlog(n))</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">len(nums)</span></code> - worst-case: sorting <code class="docutils literal notranslate"><span class="pre">n</span></code> items (all unique)</p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">len(nums)</span></code> - worst-case: <code class="docutils literal notranslate"><span class="pre">myDict</span></code> contains <code class="docutils literal notranslate"><span class="pre">n</span></code> items (all unique)</p></li>
</ul>
<p>LeetCode’s solution 1: Heap</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="c1"># O(1) time</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nums</span>

    <span class="c1"># 1. build hash map : character and how often it appears</span>
    <span class="c1"># O(N) time</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="c1"># 2-3. build heap of top k frequent elements and</span>
    <span class="c1"># convert it into an output array</span>
    <span class="c1"># O(N log k) time</span>
    <span class="k">return</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">count</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Java</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// O(1) time</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 1. build hash map : character and how often it appears</span>
    <span class="c1">// O(N) time</span>
    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">count</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">count</span><span class="p">.</span><span class="na">getOrDefault</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// init heap &#39;the less frequent element first&#39;</span>
    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;</span><span class="p">(</span>
        <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">count</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">-</span> <span class="n">count</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">n2</span><span class="p">));</span>

    <span class="c1">// 2. keep k top frequent elements in the heap</span>
    <span class="c1">// O(N log k) &lt; O(N log N) time</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">:</span> <span class="n">count</span><span class="p">.</span><span class="na">keySet</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">heap</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="n">heap</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 3. build an output array</span>
    <span class="c1">// O(k log k) time</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">top</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">top</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>Effective <code class="docutils literal notranslate"><span class="pre">O(1)</span></code> best-case implementation (first two lines)</p></li>
<li><p>In Python, library <code class="docutils literal notranslate"><span class="pre">heapq</span></code> provides a method <code class="docutils literal notranslate"><span class="pre">nlargest</span></code>, which combines the last two steps under the hood and has
the same <span class="math notranslate nohighlight">\(\mathcal{O}(N \log k)\)</span> time complexity.</p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(nlog(k))</span></code></p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n+k)</span></code> to store a hash map with no more than <code class="docutils literal notranslate"><span class="pre">n</span></code> elements and a heap with <code class="docutils literal notranslate"><span class="pre">k</span></code> elements.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">collections.Counter</span></code> is a dictionary subclass for counting hashable objects. Elements are stored as dictionary keys
and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or
negative counts. The Counter class is similar to bags or multisets in other languages. Please refer to the summary I created
at <a class="reference internal" href="toolbox.html#counter"><span class="std std-ref">Counter</span></a>.</p>
</div>
<p>LeetCode’s solution 2: Quickselect (Hoare’s selection algorithm)</p>
<p><strong>From LeetCode:</strong> Quickselect is a textbook algorthm typically used to solve the problems “find <code class="docutils literal notranslate"><span class="pre">k</span></code> th something”: <code class="docutils literal notranslate"><span class="pre">k</span></code> th smallest, <code class="docutils literal notranslate"><span class="pre">k</span></code> th largest, <code class="docutils literal notranslate"><span class="pre">k</span></code> th most
frequent, <code class="docutils literal notranslate"><span class="pre">k</span></code> th less frequent, etc. Like quicksort, quickselect was developed by Tony Hoare, and also known as Hoare’s selection algorithm.</p>
<p>It has <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> average time complexity and widely used in practice. It worth to note that its worth case time complexity
is <span class="math notranslate nohighlight">\(\mathcal{O}(N^2)\)</span>, although the probability of this worst-case is negligible.</p>
<p>As an output, we have an array where the pivot is on its perfect position in the ascending sorted array, sorted by the frequency.
All elements on the left of the pivot are less frequent than the pivot, and all elements on the right are more frequent or have the same frequency.</p>
<p>Hence the array is now split into two parts. If by chance our pivot element took <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">k</span></code> th final position, then kk elements on the right are
these top k frequent we’re looking for. If not, we can choose one more pivot and place it in its perfect position.</p>
<p>If that were a quicksort algorithm, one would have to process both parts of the array. That would result in <span class="math notranslate nohighlight">\(\mathcal{O}(N \log N)\)</span>
time complexity. In this case, there is no need to deal with both parts since one knows in which part to search for N - kth less frequent
element, and that reduces the average time complexity to <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span>.</p>
<dl class="simple">
<dt>Algorithm</dt><dd><ul class="simple">
<li><p>Build a hash map element -&gt; its frequency and convert its keys into the array unique of unique elements. Note that elements are
unique, but their frequencies are not. That means we need a partition algorithm that works fine with duplicates.</p></li>
<li><p>Work with unique array. Use a partition scheme (please check the next section) to place the pivot into its perfect position
pivot_index in the sorted array, move less frequent elements to the left of pivot, and more frequent or of the same frequency - to the right.</p></li>
<li><p>Compare pivot_index and N - k:</p></li>
<li><p>If pivot_index == N - k, the pivot is N - kth most frequent element, and all elements on the right are more frequent or of the same frequency.
Return these top k frequent elements.</p></li>
<li><p>Otherwise, choose the side of the array to proceed recursively.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
     <span class="n">count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
     <span class="n">unique</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

     <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pivot_index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
         <span class="n">pivot_frequency</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">unique</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">]]</span>
         <span class="c1"># 1. move pivot to end</span>
         <span class="n">unique</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">],</span> <span class="n">unique</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">unique</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">]</span>

         <span class="c1"># 2. move all less frequent elements to the left</span>
         <span class="n">store_index</span> <span class="o">=</span> <span class="n">left</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
             <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">unique</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">pivot_frequency</span><span class="p">:</span>
                 <span class="n">unique</span><span class="p">[</span><span class="n">store_index</span><span class="p">],</span> <span class="n">unique</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">unique</span><span class="p">[</span><span class="n">store_index</span><span class="p">]</span>
                 <span class="n">store_index</span> <span class="o">+=</span> <span class="mi">1</span>

         <span class="c1"># 3. move pivot to its final place</span>
         <span class="n">unique</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">unique</span><span class="p">[</span><span class="n">store_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique</span><span class="p">[</span><span class="n">store_index</span><span class="p">],</span> <span class="n">unique</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>

         <span class="k">return</span> <span class="n">store_index</span>

     <span class="k">def</span> <span class="nf">quickselect</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">k_smallest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
         <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Sort a list within left..right till kth less frequent element</span>
<span class="sd">         takes its place.</span>
<span class="sd">         &quot;&quot;&quot;</span>
         <span class="c1"># base case: the list contains only one element</span>
         <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
             <span class="k">return</span>

         <span class="c1"># select a random pivot_index</span>
         <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

         <span class="c1"># find the pivot position in a sorted list</span>
         <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pivot_index</span><span class="p">)</span>

         <span class="c1"># if the pivot is in its final sorted position</span>
         <span class="k">if</span> <span class="n">k_smallest</span> <span class="o">==</span> <span class="n">pivot_index</span><span class="p">:</span>
              <span class="k">return</span>
         <span class="c1"># go left</span>
         <span class="k">elif</span> <span class="n">k_smallest</span> <span class="o">&lt;</span> <span class="n">pivot_index</span><span class="p">:</span>
             <span class="n">quickselect</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">pivot_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k_smallest</span><span class="p">)</span>
         <span class="c1"># go right</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="n">quickselect</span><span class="p">(</span><span class="n">pivot_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">k_smallest</span><span class="p">)</span>

     <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">)</span>
     <span class="c1"># kth top frequent element is (n - k)th less frequent.</span>
     <span class="c1"># Do a partial sort: from less frequent to the most frequent, till</span>
     <span class="c1"># (n - k)th less frequent element takes its place (n - k) in a sorted array.</span>
     <span class="c1"># All element on the left are less frequent.</span>
     <span class="c1"># All the elements on the right are more frequent.</span>
     <span class="n">quickselect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
     <span class="c1"># Return top k frequent elements</span>
     <span class="k">return</span> <span class="n">unique</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">:]</span>
</pre></div>
</div>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Java</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">unique</span><span class="p">;</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">unique</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="p">;</span>
    <span class="n">unique</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">unique</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="p">;</span>
    <span class="n">unique</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pivot_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pivot_frequency</span> <span class="o">=</span> <span class="n">count</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">unique</span><span class="o">[</span><span class="n">pivot_index</span><span class="o">]</span><span class="p">);</span>
    <span class="c1">// 1. move pivot to end</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">pivot_index</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">store_index</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

    <span class="c1">// 2. move all less frequent elements to the left</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">unique</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pivot_frequency</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">store_index</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">store_index</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 3. move pivot to its final place</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">store_index</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">store_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">quickselect</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k_smallest</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">    Sort a list within left..right till kth less frequent element</span>
<span class="cm">    takes its place.</span>
<span class="cm">    */</span>

    <span class="c1">// base case: the list contains only one element</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// select a random pivot_index</span>
    <span class="n">Random</span> <span class="n">random_num</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">random_num</span><span class="p">.</span><span class="na">nextInt</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">);</span>

    <span class="c1">// find the pivot position in a sorted list</span>
    <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pivot_index</span><span class="p">);</span>

    <span class="c1">// if the pivot is in its final sorted position</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k_smallest</span> <span class="o">==</span> <span class="n">pivot_index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">k_smallest</span> <span class="o">&lt;</span> <span class="n">pivot_index</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// go left</span>
        <span class="n">quickselect</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">pivot_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k_smallest</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// go right</span>
        <span class="n">quickselect</span><span class="p">(</span><span class="n">pivot_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">k_smallest</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// build hash map : character and how often it appears</span>
    <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">count</span><span class="p">.</span><span class="na">getOrDefault</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// array of unique elements</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">count</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
    <span class="n">unique</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">:</span> <span class="n">count</span><span class="p">.</span><span class="na">keySet</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">unique</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// kth top frequent element is (n - k)th less frequent.</span>
    <span class="c1">// Do a partial sort: from less frequent to the most frequent, till</span>
    <span class="c1">// (n - k)th less frequent element takes its place (n - k) in a sorted array.</span>
    <span class="c1">// All element on the left are less frequent.</span>
    <span class="c1">// All the elements on the right are more frequent.</span>
    <span class="n">quickselect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">);</span>
    <span class="c1">// Return top k frequent elements</span>
    <span class="k">return</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">copyOfRange</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>Effective <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> average-case <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> implementation (first two lines)</p></li>
<li><p>In Python, library <code class="docutils literal notranslate"><span class="pre">heapq</span></code> provides a method <code class="docutils literal notranslate"><span class="pre">nlargest</span></code>, which combines the last two steps under the hood and has
the same <span class="math notranslate nohighlight">\(\mathcal{O}(N \log k)\)</span> time complexity.</p></li>
<li><p><strong>Time Complexity</strong>: average-case - <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> ; worst-case - <code class="docutils literal notranslate"><span class="pre">O(n^2)</span></code> : In the worst-case of constantly bad chosen pivots, the
problem is not divided by half at each step, it becomes just one element less, that leads to <span class="math notranslate nohighlight">\(\mathcal{O}(N^2)\)</span> time
complexity. It happens, for example, if at each step you choose the pivot not randomly, but take the rightmost element. For
the random pivot choice the probability of having such a worst-case is negligibly small.</p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> to store hash map and array of unique elements.</p></li>
</ul>
</dd>
</dl>
<p>An <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> solution: Bucket Sort (cred: <a class="reference external" href="https://leetcode.com/problems/top-k-frequent-elements/discuss/740374/Python-5-lines-O(n)-buckets-solution-explained">DBabi</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">bucket</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">Count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">Count</span><span class="p">:</span> <span class="n">bucket</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">bucket</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">flat_list</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="day-20-5-nov">
<h2>Day 20 [5 Nov]<a class="headerlink" href="#day-20-5-nov" title="Permalink to this headline"></a></h2>
<section id="question-35-remove-duplicates-from-sorted-list-ii">
<h3>Question 35: Remove Duplicates from Sorted List II<a class="headerlink" href="#question-35-remove-duplicates-from-sorted-list-ii" title="Permalink to this headline"></a></h3>
<p><em>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct
numbers from the original list. Return the linked list sorted as well.</em></p>
<p>My failed solution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
    <span class="n">dummyHead</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">dummyHead</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
            <span class="n">shift</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="k">return</span> <span class="n">dummyHead</span><span class="o">.</span><span class="n">next</span>
        <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">shift</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_val</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span>
            <span class="k">while</span> <span class="n">curr_val</span> <span class="o">==</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">curr</span><span class="p">:</span>
                    <span class="k">break</span>
    <span class="k">return</span> <span class="n">dummyHead</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
<p>LeetCode’s Solution 1: Sentinel Head + Predecessor</p>
<p><em>LeetCode:</em> Sentinel nodes are widely used for trees and linked lists as pseudo-heads, pseudo-tails, etc. They are
purely functional and usually don’t hold any data. Their primary purpose is to standardize the situation to avoid edge
case handling. For example, let’s use here pseudo-head with zero value to ensure that the situation “delete the list
head” could never happen, and all nodes to delete are “inside” the list.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
    <span class="c1"># attach sentinel head to the given list</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>

    <span class="c1"># predecessor = the last node before the sublist of duplicates</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">sentinel</span>

    <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
        <span class="c1"># if it&#39;s a beginning of duplicates sublist</span>
        <span class="c1"># skip all duplicates</span>
        <span class="k">if</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="ow">and</span> <span class="n">head</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="c1"># move till the end of duplicates sublist</span>
            <span class="k">while</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="ow">and</span> <span class="n">head</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
            <span class="c1"># skip all duplicates</span>
            <span class="n">pred</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># otherwise, move predecessor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">next</span>

        <span class="c1"># move forward</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

    <span class="k">return</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Java</span>
<span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">deleteDuplicates</span><span class="p">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// sentinel</span>
    <span class="n">ListNode</span> <span class="n">sentinel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

    <span class="c1">// predecessor = the last node</span>
    <span class="c1">// before the sublist of duplicates</span>
    <span class="n">ListNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">sentinel</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// if it&#39;s a beginning of duplicates sublist</span>
        <span class="c1">// skip all duplicates</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="p">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="p">.</span><span class="na">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// move till the end of duplicates sublist</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="p">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="p">.</span><span class="na">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// skip all duplicates</span>
            <span class="n">pred</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
        <span class="c1">// otherwise, move predecessor</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// move forward</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sentinel</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>It’s always important to think about the algorithm critically and extensively before implementing it with code. The more
you take to think about the problem and your algorithm (without coding), the more structured, organized and efficient your
code will be.</p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> - one pass through the list!</p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(1)</span></code> - we don’t allocate any additional data structure</p></li>
</ul>
</dd>
</dl>
</section>
</section>
<section id="day-21-6-nov">
<h2>Day 21 [6 Nov]<a class="headerlink" href="#day-21-6-nov" title="Permalink to this headline"></a></h2>
<section id="question-36-excel-sheet-column-title">
<h3>Question 36: Excel Sheet Column Title<a class="headerlink" href="#question-36-excel-sheet-column-title" title="Permalink to this headline"></a></h3>
<p><em>Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.</em></p>
<p>My solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">convertToTitle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columnNumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="linenos"> 2</span>        <span class="k">if</span> <span class="n">columnNumber</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="linenos"> 3</span>            <span class="k">return</span> <span class="kc">None</span>
<span class="linenos"> 4</span>        <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="linenos"> 5</span>        <span class="k">while</span> <span class="n">columnNumber</span><span class="p">:</span>
<span class="linenos"> 6</span>            <span class="n">resNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">columnNumber</span><span class="o">%</span><span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="mi">64</span>
<span class="linenos"> 7</span>            <span class="k">if</span> <span class="n">resNum</span><span class="o">==</span><span class="mi">64</span><span class="p">:</span>
<span class="linenos"> 8</span>                <span class="n">resNum</span> <span class="o">=</span> <span class="mi">90</span>
<span class="linenos"> 9</span>            <span class="n">res</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">resNum</span><span class="p">)</span> <span class="o">+</span> <span class="n">res</span>
<span class="linenos">10</span>            <span class="n">columnNumber</span> <span class="o">//=</span> <span class="mi">26</span>
<span class="linenos">11</span>            <span class="k">if</span> <span class="n">resNum</span> <span class="o">==</span> <span class="mi">90</span><span class="p">:</span>
<span class="linenos">12</span>                <span class="n">columnNumber</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="linenos">13</span>        <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>Surprisingly a great question that made me think for a while. There were several “edge-cases” that appeared
while implementing my solution.</p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(?)</span></code> - uncertain</p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(1)</span></code> - we don’t allocate any additional data structure</p></li>
</ul>
</dd>
</dl>
<p>Alternative solutions (cred: <a class="reference external" href="https://leetcode.com/problems/excel-sheet-column-title/discuss/51398/My-1-lines-code-in-Java-C%2B%2B-and-Python">xcv</a>):</p>
<div class="highlight-Java notranslate"><div class="highlight"><pre><span></span><span class="c1">// Java</span>
<span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="p">:</span> <span class="n">convertToTitle</span><span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="o">/</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">26</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Python</span>
<span class="k">return</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertToTitle</span><span class="p">((</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">((</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">26</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">))</span>

<span class="c1"># Alternatively...</span>
<span class="k">def</span> <span class="nf">convertToTitle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="n">capitals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">capitals</span><span class="p">[(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span><span class="p">])</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">26</span>
    <span class="n">result</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="day-22-7-nov">
<h2>Day 22 [7 Nov]<a class="headerlink" href="#day-22-7-nov" title="Permalink to this headline"></a></h2>
<section id="question-37-isomorphic-strings">
<h3>Question 37: Isomorphic Strings<a class="headerlink" href="#question-37-isomorphic-strings" title="Permalink to this headline"></a></h3>
<p><em>Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters
in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving
the order of characters. No two characters may map to the same character, but a character may map to itself.</em></p>
<p>My solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">isIsomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos"> 2</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="linenos"> 3</span>            <span class="k">return</span> <span class="kc">False</span>
<span class="linenos"> 4</span>        <span class="n">s_to_t</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos"> 5</span>        <span class="k">for</span> <span class="n">s_elt</span><span class="p">,</span> <span class="n">t_elt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="linenos"> 6</span>            <span class="k">if</span> <span class="n">s_elt</span> <span class="ow">in</span> <span class="n">s_to_t</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<span class="linenos"> 7</span>                <span class="k">if</span> <span class="n">s_to_t</span><span class="p">[</span><span class="n">s_elt</span><span class="p">]</span> <span class="o">!=</span> <span class="n">t_elt</span><span class="p">:</span>
<span class="linenos"> 8</span>                    <span class="k">return</span> <span class="kc">False</span>
<span class="linenos"> 9</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos">10</span>                    <span class="k">continue</span>
<span class="linenos">11</span>
<span class="linenos">12</span>            <span class="k">if</span> <span class="n">t_elt</span> <span class="ow">in</span> <span class="n">s_to_t</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
<span class="linenos">13</span>                <span class="k">return</span> <span class="kc">False</span>
<span class="linenos">14</span>            <span class="n">s_to_t</span><span class="p">[</span><span class="n">s_elt</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_elt</span>
<span class="linenos">15</span>        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
<dl class="simple">
<dt>Remarks and Complexity Analysis:</dt><dd><ul class="simple">
<li><p>Pretty simple question</p></li>
<li><p><strong>Time Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> - where <code class="docutils literal notranslate"><span class="pre">n=min(len(s),</span> <span class="pre">len(t))</span></code></p></li>
<li><p><strong>Space Complexity</strong>: <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> - we keep a dictionary of all the unique characters in <code class="docutils literal notranslate"><span class="pre">s</span></code> (and their values)</p></li>
</ul>
</dd>
</dl>
<p>Alternative solution (cred: LeetCode):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transformString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">index_mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">new_str</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index_mapping</span><span class="p">:</span>
            <span class="n">index_mapping</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">new_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index_mapping</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>

    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_str</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isIsomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformString</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="week3.html" class="btn btn-neutral float-left" title="Week 3 [25-31 Oct 2021]" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="week5.html" class="btn btn-neutral float-right" title="Week 5 [8-14 Nov 2021]" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Bin Choi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>